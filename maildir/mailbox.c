/**
 * @file
 * Maildir Mailbox
 *
 * @authors
 * Copyright (C) 2024 Richard Russon <rich@flatcap.org>
 *
 * @copyright
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @page maildir_mailbox Maildir Mailbox
 *
 * Maildir Mailbox
 */

#include "config.h"
#include <dirent.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include "private.h"
#include "mutt/lib.h"
#include "config/lib.h"
#include "email/lib.h"
#include "mailbox.h"
#include "progress/lib.h"
#include "edata.h"
#include "hcache.h"
#include "mdata.h"
#include "mdemail.h"
#include "mx.h"
#include "shared.h"
#ifdef USE_HCACHE
#include "hcache/lib.h"
#else
struct HeaderCache;
#endif
#ifdef USE_INOTIFY
#include "monitor.h"
#endif

struct Progress;
struct timespec;

enum MxStatus maildir_check_slow(struct Mailbox *m, bool force);

typedef uint8_t MaildirCheckFlags; ///< Which directories need checking? e.g. MMC_NEW_DIR
#define MMC_NO_DIRS 0              ///< No directories changed
#define MMC_NEW_DIR (1 << 0) ///< 'new' directory changed
#define MMC_CUR_DIR (1 << 1) ///< 'cur' directory changed

// clang-format off
typedef uint8_t EmailCompareFlags;  ///< Has an Email changed? e.g. #MD_EC_FILENAME
#define MD_EC_NO_FLAGS           0  ///< No flags are set
#define MD_EC_FILENAME     (1 << 0) ///< Filename changed
#define MD_EC_DIRECTORY    (1 << 1) ///< Directory changed, e.g. new to cur
#define MD_EC_FLAGS        (1 << 2) ///< Flags changed
#define MD_EC_CUSTOM_FLAGS (1 << 3) ///< Custom flags changed
// clang-format on

/**
 * maildir_email_new - Create a Maildir Email
 * @retval ptr Newly created Email
 *
 * Create a new Email and attach MaildirEmailData.
 *
 * @note This should be freed using email_free()
 */
struct Email *maildir_email_new(void)
{
  struct Email *e = email_new();
  e->edata = maildir_edata_new();
  e->edata_free = maildir_edata_free;

  return e;
}

/**
 * maildir_parse_flags - Parse Maildir file flags
 * @param e    Email
 * @param path Path to email file
 */
void maildir_parse_flags(struct Email *e, const char *path)
{
  char *q = NULL;

  e->flagged = false;
  e->read = false;
  e->replied = false;

  struct MaildirEmailData *edata = maildir_edata_get(e);
  if (!edata)
  {
    e->edata = maildir_edata_new();
    edata = e->edata;
  }

  const char c_maildir_field_delimiter = *cc_maildir_field_delimiter();
  char *p = strrchr(path, c_maildir_field_delimiter);
  if (p && mutt_str_startswith(p + 1, "2,"))
  {
    p += 3;

    mutt_str_replace(&edata->custom_flags, p);
    q = edata->custom_flags;

    while (*p)
    {
      switch (*p)
      {
        case 'F': // Flagged
          e->flagged = true;
          break;

        case 'R': // Replied
          e->replied = true;
          break;

        case 'S': // Seen
          e->read = true;
          break;

        case 'T': // Trashed
        {
          const bool c_flag_safe = cs_subset_bool(NeoMutt->sub, "flag_safe");
          if (!e->flagged || !c_flag_safe)
          {
            e->trash = true;
            e->deleted = true;
          }
          break;
        }

        default:
          *q++ = *p;
          break;
      }
      p++;
    }
  }

  if (q == edata->custom_flags)
    FREE(&edata->custom_flags);
  else if (q)
    *q = '\0';
}

/**
 * maildir_parse_stream - Parse a Maildir message
 * @param fp     Message file handle
 * @param fname  Message filename
 * @param is_old true, if the email is old (read)
 * @param e      Email
 * @retval true Success
 *
 * Actually parse a maildir message.  This may also be used to fill
 * out a fake header structure generated by lazy maildir parsing.
 */
bool maildir_parse_stream(FILE *fp, const char *fname, bool is_old, struct Email *e)
{
  if (!fp || !fname || !e)
    return false;

  const long size = mutt_file_get_size_fp(fp);
  if (size == 0)
    return false;

  e->env = mutt_rfc822_read_header(fp, e, false, false);

  if (e->received == 0)
    e->received = e->date_sent;

  /* always update the length since we have fresh information available. */
  e->body->length = size - e->body->offset;

  e->index = -1;
  e->old = is_old;
  return e;
}

/**
 * maildir_parse_message - Actually parse a maildir message
 * @param fname  Message filename
 * @param is_old true, if the email is old (read)
 * @param e      Email to populate
 * @retval true Success
 *
 * This may also be used to fill out a fake header structure generated by lazy
 * maildir parsing.
 */
bool maildir_parse_message(const char *fname, bool is_old, struct Email *e)
{
  if (!fname || !e)
    return false;

  FILE *fp = mutt_file_fopen(fname, "r");
  if (!fp)
    return false;

  bool rc = maildir_parse_stream(fp, fname, is_old, e);
  mutt_file_fclose(&fp);
  return rc;
}

/**
 * maildir_move_to_mailbox - Copy the Maildir list to the Mailbox
 * @param[in]  m   Mailbox
 * @param[out] mda Maildir array to copy, then free
 * @retval num Number of new emails
 * @retval 0   Error
 */
int maildir_move_to_mailbox(struct Mailbox *m, const struct MdEmailArray *mda)
{
  if (!m)
    return 0;

  int oldmsgcount = m->msg_count;

  struct MdEmail *md = NULL;
  struct MdEmail **mdp = NULL;
  ARRAY_FOREACH(mdp, mda)
  {
    md = *mdp;
    mutt_debug(LL_DEBUG2, "Considering %s\n", NONULL(md->canon_fname));
    if (!md->email)
      continue;

    mutt_debug(LL_DEBUG2, "Adding header structure. Flags: %s%s%s%s%s\n",
               md->email->flagged ? "f" : "", md->email->deleted ? "D" : "",
               md->email->replied ? "r" : "", md->email->old ? "O" : "",
               md->email->read ? "R" : "");
    mx_alloc_memory(m, m->msg_count);

    m->emails[m->msg_count] = md->email;
    m->emails[m->msg_count]->index = m->msg_count;
    mailbox_size_add(m, md->email);

    md->email = NULL;
    m->msg_count++;
  }

  int num = 0;
  if (m->msg_count > oldmsgcount)
    num = m->msg_count - oldmsgcount;

  return num;
}

/**
 * maildir_sort_inode - Compare two Maildirs by inode number - Implements ::sort_t - @ingroup sort_api
 */
static int maildir_sort_inode(const void *a, const void *b, void *sdata)
{
  const struct MdEmail *ma = *(struct MdEmail **) a;
  const struct MdEmail *mb = *(struct MdEmail **) b;

  return mutt_numeric_cmp(ma->inode, mb->inode);
}

/**
 * maildir_parse_dir - Read a Maildir mailbox
 * @param[in]  m        Mailbox
 * @param[out] mda      Array for results
 * @param[in]  subdir   Subdirectory, e.g. 'new'
 * @param[in]  progress Progress bar
 * @retval  0 Success
 * @retval -1 Error
 * @retval -2 Aborted
 */
static int maildir_parse_dir(struct Mailbox *m, struct MdEmailArray *mda,
                             const char *subdir, struct Progress *progress)
{
  struct dirent *de = NULL;
  int rc = 0;
  bool is_old = false;
  struct MdEmail *entry = NULL;
  struct Email *e = NULL;

  struct Buffer *buf = buf_pool_get();

  buf_printf(buf, "%s/%s", mailbox_path(m), subdir);
  is_old = mutt_str_equal("cur", subdir);

  DIR *dir = mutt_file_opendir(buf_string(buf), MUTT_OPENDIR_CREATE);
  if (!dir)
  {
    rc = -1;
    goto cleanup;
  }

  while (((de = readdir(dir))) && !SigInt)
  {
    if (*de->d_name == '.')
      continue;

    mutt_debug(LL_DEBUG2, "queueing %s\n", de->d_name);

    e = maildir_email_new();
    e->old = is_old;
    maildir_parse_flags(e, de->d_name);

    progress_update(progress, ARRAY_SIZE(mda) + 1, -1);

    buf_concat_path(buf, subdir, de->d_name);
    e->path = buf_strdup(buf);

    entry = maildir_entry_new();
    entry->email = e;
    entry->inode = de->d_ino;
    ARRAY_ADD(mda, entry);
  }

  closedir(dir);

  if (SigInt)
  {
    SigInt = false; // LCOV_EXCL_LINE
    return -2;      // LCOV_EXCL_LINE
  }

  ARRAY_SORT(mda, maildir_sort_inode, NULL);

cleanup:
  buf_pool_release(&buf);

  return rc;
}

/**
 * maildir_delayed_parsing - This function does the second parsing pass
 * @param[in]  m   Mailbox
 * @param[out] mda Maildir array to parse
 * @param[in]  progress Progress bar
 */
static void maildir_delayed_parsing(struct Mailbox *m, struct MdEmailArray *mda,
                                    struct Progress *progress)
{
  char fn[PATH_MAX] = { 0 };

#ifdef USE_HCACHE
  const char *const c_header_cache = cs_subset_path(NeoMutt->sub, "header_cache");
  struct HeaderCache *hc = hcache_open(c_header_cache, mailbox_path(m), NULL, true);
  const bool c_maildir_header_cache_verify = cs_subset_bool(NeoMutt->sub, "maildir_header_cache_verify");
#endif

  struct MdEmail *md = NULL;
  struct MdEmail **mdp = NULL;
  ARRAY_FOREACH(mdp, mda)
  {
    md = *mdp;
    if (!md || !md->email || md->header_parsed)
      continue;

    progress_update(progress, ARRAY_FOREACH_IDX_mdp, -1);

    snprintf(fn, sizeof(fn), "%s/%s", mailbox_path(m), md->email->path);

#ifdef USE_HCACHE
    struct stat st_lastchanged = { 0 };
    int rc = 0;

    const char *key = maildir_hcache_key(md->email);
    size_t keylen = maildir_hcache_keylen(key);
    struct HCacheEntry hce = { 0 };

    if (hc)
    {
      hce = hcache_fetch_email(hc, key, keylen, 0);
    }

    if (hce.email && c_maildir_header_cache_verify)
    {
      rc = stat(fn, &st_lastchanged);
    }

    if (hce.email && (rc == 0) && (st_lastchanged.st_mtime <= hce.uidvalidity))
    {
      hce.email->edata = maildir_edata_new();
      hce.email->edata_free = maildir_edata_free;
      hce.email->old = md->email->old;
      hce.email->path = mutt_str_dup(md->email->path);
      email_free(&md->email);
      md->email = hce.email;
      maildir_parse_flags(md->email, fn);
    }
    else
#endif
    {
      if (maildir_parse_message(fn, md->email->old, md->email))
      {
        md->header_parsed = true;
#ifdef USE_HCACHE
        key = maildir_hcache_key(md->email);
        keylen = maildir_hcache_keylen(key);
        hcache_store_email(hc, key, keylen, md->email, 0);
#endif
      }
      else
      {
        email_free(&md->email);
      }
    }
  }
#ifdef USE_HCACHE
  hcache_close(&hc);
#endif
}

/**
 * maildir_check_dir - Check for new mail / mail counts
 * @param m           Mailbox to check
 * @param dir_name    Path to Mailbox
 * @param check_new   if true, check for new mail
 * @param check_stats if true, count total, new, and flagged messages
 *
 * Checks the specified maildir subdir (cur or new) for new mail or mail counts.
 */
static void maildir_check_dir(struct Mailbox *m, const char *dir_name,
                              bool check_new, bool check_stats)
{
  DIR *dir = NULL;
  struct dirent *de = NULL;
  char *p = NULL;
  struct stat st = { 0 };

  struct Buffer *path = buf_pool_get();
  struct Buffer *msgpath = buf_pool_get();
  buf_printf(path, "%s/%s", mailbox_path(m), dir_name);

  /* when $mail_check_recent is set, if the new/ directory hasn't been modified since
   * the user last exited the mailbox, then we know there is no recent mail.  */
  const bool c_mail_check_recent = cs_subset_bool(NeoMutt->sub, "mail_check_recent");
  if (check_new && c_mail_check_recent)
  {
    if ((stat(buf_string(path), &st) == 0) &&
        (mutt_file_stat_timespec_compare(&st, MUTT_STAT_MTIME, &m->last_visited) < 0))
    {
      check_new = false;
    }
  }

  if (!(check_new || check_stats))
    goto cleanup;

  dir = mutt_file_opendir(buf_string(path), MUTT_OPENDIR_CREATE);
  if (!dir)
  {
    m->type = MUTT_UNKNOWN;
    goto cleanup;
  }

  const char c_maildir_field_delimiter = *cc_maildir_field_delimiter();

  char delimiter_version[8] = { 0 };
  snprintf(delimiter_version, sizeof(delimiter_version), "%c2,", c_maildir_field_delimiter);
  while ((de = readdir(dir)))
  {
    if (*de->d_name == '.')
      continue;

    p = strstr(de->d_name, delimiter_version);
    if (p && strchr(p + 3, 'T'))
      continue;

    if (check_stats)
    {
      m->msg_count++;
      if (p && strchr(p + 3, 'F'))
        m->msg_flagged++;
    }
    if (!p || !strchr(p + 3, 'S'))
    {
      if (check_stats)
        m->msg_unread++;
      if (check_new)
      {
        if (c_mail_check_recent)
        {
          buf_printf(msgpath, "%s/%s", buf_string(path), de->d_name);
          /* ensure this message was received since leaving this m */
          if ((stat(buf_string(msgpath), &st) == 0) &&
              (mutt_file_stat_timespec_compare(&st, MUTT_STAT_CTIME, &m->last_visited) <= 0))
          {
            continue;
          }
        }
        m->has_new = true;
        if (check_stats)
        {
          m->msg_new++;
        }
        else
        {
          break;
        }
      }
    }
  }

  closedir(dir);

cleanup:
  buf_pool_release(&path);
  buf_pool_release(&msgpath);
}

/**
 * maildir_files_read_dir - Read a Maildir style mailbox
 * @param m      Mailbox
 * @param subdir Subdir of the maildir mailbox to read from
 * @retval  0 Success
 * @retval -1 Failure
 */
int maildir_files_read_dir(struct Mailbox *m, const char *subdir)
{
  if (!m)
    return -1;

  mutt_path_tidy(&m->pathbuf, true);

  struct Progress *progress = NULL;

  if (m->verbose)
  {
    progress = progress_new(MUTT_PROGRESS_READ, 0);
    progress_set_message(progress, _("Scanning %s..."), mailbox_path(m));
  }

  struct MaildirMboxData *mdata = maildir_mdata_get(m);
  if (!mdata)
  {
    mdata = maildir_mdata_new();
    m->mdata = mdata;
    m->mdata_free = maildir_mdata_free;
  }

  struct MdEmailArray mda = ARRAY_HEAD_INITIALIZER;
  int rc = maildir_parse_dir(m, &mda, subdir, progress);
  progress_free(&progress);
  if (rc < 0)
    return -1;

  if (m->verbose)
  {
    progress = progress_new(MUTT_PROGRESS_READ, ARRAY_SIZE(&mda));
    progress_set_message(progress, _("Reading %s..."), mailbox_path(m));
  }
  maildir_delayed_parsing(m, &mda, progress);
  progress_free(&progress);

  maildir_move_to_mailbox(m, &mda);
  maildirarray_clear(&mda);

  if (!mdata->umask)
    mdata->umask = maildir_umask(m);

  return 0;
}

/**
 * maildir_check - Check for new mail
 * @param m Mailbox
 * @retval enum #MxStatus
 *
 * This function handles arrival of new mail and reopening of maildir folders.
 * The basic idea here is we check to see if either the new or cur
 * subdirectories have changed, and if so, we scan them for the list of files.
 * We check for newly added messages, and then merge the flags messages we
 * already knew about.  We don't treat either subdirectory differently, as mail
 * could be copied directly into the cur directory from another agent.
 */
static enum MxStatus maildir_check(struct Mailbox *m)
{
  maildir_check_slow(m, true);
  return MX_STATUS_OK;

  struct stat st_new = { 0 }; /* status of the "new" subdirectory */
  struct stat st_cur = { 0 }; /* status of the "cur" subdirectory */
  int changed = MMC_NO_DIRS;  /* which subdirectories have changed */
  bool occult = false;        /* messages were removed from the mailbox */
  int num_new = 0;            /* number of new messages added to the mailbox */
  bool flags_changed = false; /* message flags were changed in the mailbox */
  struct HashTable *hash_names = NULL; // Hash Table: "base-filename" -> MdEmail
  struct MaildirMboxData *mdata = maildir_mdata_get(m);

  const bool c_check_new = cs_subset_bool(NeoMutt->sub, "check_new");
  if (!c_check_new)
    return MX_STATUS_OK;

  struct Buffer *buf = buf_pool_get();
  buf_printf(buf, "%s/new", mailbox_path(m));
  if (stat(buf_string(buf), &st_new) == -1)
  {
    buf_pool_release(&buf);
    return MX_STATUS_ERROR;
  }

  buf_printf(buf, "%s/cur", mailbox_path(m));
  if (stat(buf_string(buf), &st_cur) == -1)
  {
    buf_pool_release(&buf);
    return MX_STATUS_ERROR;
  }

  /* determine which subdirectories need to be scanned */
  if (mutt_file_stat_timespec_compare(&st_new, MUTT_STAT_MTIME, &mdata->mtime) > 0)
    changed = MMC_NEW_DIR;
  if (mutt_file_stat_timespec_compare(&st_cur, MUTT_STAT_MTIME, &mdata->mtime_cur) > 0)
    changed |= MMC_CUR_DIR;

  if (changed == MMC_NO_DIRS)
  {
    buf_pool_release(&buf);
    return MX_STATUS_OK; /* nothing to do */
  }

  /* Update the modification times on the mailbox.
   *
   * The monitor code notices changes in the open mailbox too quickly.
   * In practice, this sometimes leads to all the new messages not being
   * noticed during the SAME group of mtime stat updates.  To work around
   * the problem, don't update the stat times for a monitor caused check. */
#ifdef USE_INOTIFY
  if (MonitorCurMboxChanged)
  {
    MonitorCurMboxChanged = false;
  }
  else
#endif
  {
    mutt_file_get_stat_timespec(&mdata->mtime_cur, &st_cur, MUTT_STAT_MTIME);
    mutt_file_get_stat_timespec(&mdata->mtime, &st_new, MUTT_STAT_MTIME);
  }

  /* do a fast scan of just the filenames in
   * the subdirectories that have changed.  */
  struct MdEmailArray mda = ARRAY_HEAD_INITIALIZER;
  if (changed & MMC_NEW_DIR)
    maildir_parse_dir(m, &mda, "new", NULL);
  if (changed & MMC_CUR_DIR)
    maildir_parse_dir(m, &mda, "cur", NULL);

  /* we create a hash table keyed off the canonical (sans flags) filename
   * of each message we scanned.  This is used in the loop over the
   * existing messages below to do some correlation.  */
  hash_names = mutt_hash_new(ARRAY_SIZE(&mda), MUTT_HASH_NO_FLAGS);

  struct MdEmail *md = NULL;
  struct MdEmail **mdp = NULL;
  ARRAY_FOREACH(mdp, &mda)
  {
    md = *mdp;
    maildir_canon_filename(buf, md->email->path);
    md->canon_fname = buf_strdup(buf);
    mutt_hash_insert(hash_names, md->canon_fname, md);
  }

  /* check for modifications and adjust flags */
  for (int i = 0; i < m->msg_count; i++)
  {
    struct Email *e = m->emails[i];
    if (!e)
      break;

    maildir_canon_filename(buf, e->path);
    md = mutt_hash_find(hash_names, buf_string(buf));
    if (md && md->email)
    {
      /* message already exists, merge flags */

      /* check to see if the message has moved to a different
       * subdirectory.  If so, update the associated filename.  */
      if (!mutt_str_equal(e->path, md->email->path))
        mutt_str_replace(&e->path, md->email->path);

      /* if the user hasn't modified the flags on this message, update
       * the flags we just detected.  */
      if (!e->changed)
        if (maildir_update_flags(m, e, md->email))
          flags_changed = true;

      if (e->deleted == e->trash)
      {
        if (e->deleted != md->email->deleted)
        {
          e->deleted = md->email->deleted;
          flags_changed = true;
        }
      }
      e->trash = md->email->trash;

      /* this is a duplicate of an existing email, so remove it */
      email_free(&md->email);
    }
    /* This message was not in the list of messages we just scanned.
     * Check to see if we have enough information to know if the
     * message has disappeared out from underneath us.  */
    else if (((changed & MMC_NEW_DIR) && mutt_strn_equal(e->path, "new/", 4)) ||
             ((changed & MMC_CUR_DIR) && mutt_strn_equal(e->path, "cur/", 4)))
    {
      /* This message disappeared, so we need to simulate a "reopen"
       * event.  We know it disappeared because we just scanned the
       * subdirectory it used to reside in.  */
      occult = true;
      e->deleted = true;
      e->purge = true;
    }
    else
    {
      /* This message resides in a subdirectory which was not
       * modified, so we assume that it is still present and
       * unchanged.  */
    }
  }

  /* destroy the file name hash */
  mutt_hash_free(&hash_names);

  /* If we didn't just get new mail, update the tables. */
  if (occult)
    mailbox_changed(m, NT_MAILBOX_RESORT);

  /* do any delayed parsing we need to do. */
  maildir_delayed_parsing(m, &mda, NULL);

  /* Incorporate new messages */
  num_new = maildir_move_to_mailbox(m, &mda);
  maildirarray_clear(&mda);

  if (num_new > 0)
  {
    mailbox_changed(m, NT_MAILBOX_INVALID);
    m->changed = true;
  }

  buf_pool_release(&buf);

  ARRAY_FREE(&mda);
  if (occult)
    return MX_STATUS_REOPENED;
  if (num_new > 0)
    return MX_STATUS_NEW_MAIL;
  if (flags_changed)
    return MX_STATUS_FLAGS;
  return MX_STATUS_OK;
}

/**
 * maildir_update_mtime - Update our record of the Maildir modification time
 * @param m Mailbox
 */
void maildir_update_mtime(struct Mailbox *m)
{
  char buf[PATH_MAX] = { 0 };
  struct stat st = { 0 };
  struct MaildirMboxData *mdata = maildir_mdata_get(m);

  snprintf(buf, sizeof(buf), "%s/%s", mailbox_path(m), "cur");
  if (stat(buf, &st) == 0)
    mutt_file_get_stat_timespec(&mdata->mtime_cur, &st, MUTT_STAT_MTIME);

  snprintf(buf, sizeof(buf), "%s/%s", mailbox_path(m), "new");
  if (stat(buf, &st) == 0)
    mutt_file_get_stat_timespec(&mdata->mtime, &st, MUTT_STAT_MTIME);
}

/**
 * highlight_filename - XXX
 */
static const char *highlight_filename(const char *filename, int start, int length)
{
  static char name[1024];

  if (!filename)
    return "";

  size_t nlen = 0;

  if (start > 0)
    nlen += sprintf(name + nlen, "%.*s", start, filename);

  nlen += sprintf(name + nlen, "\033[1;4;33m%.*s\033[0m", length, filename + start);

  if (filename[start + length] != '\0')
    nlen += sprintf(name + nlen, "%s", filename + start + length);

  return name;
}

/**
 * dump_filenames - XXX
 */
static void dump_filenames(const struct FilenameArray *fa, const char *title)
{
  mutt_debug(LL_DEBUG1, "------------------------------------------------------------\n");
  mutt_debug(LL_DEBUG1, "\033[1;32m%s - %d filenames\033[0m\n", title, ARRAY_SIZE(fa));

  struct Filename *fn = NULL;
  ARRAY_FOREACH(fn, fa)
  {
    mutt_debug(LL_DEBUG1, "%c %s\n", fn->is_cur ? 'C' : 'N',
               highlight_filename(fn->sub_name, fn->uid_start, fn->uid_length));
  }
}

/**
 * dump_emails - XXX
 */
static void dump_emails(const struct EmailArray *ea, const char *title)
{
  mutt_debug(LL_DEBUG1, "------------------------------------------------------------\n");
  mutt_debug(LL_DEBUG1, "\033[1;32m%s - %d emails\033[0m\n", title, ARRAY_SIZE(ea));

  struct Email **ep = NULL;
  ARRAY_FOREACH(ep, ea)
  {
    struct Email *e = *ep;
    struct MaildirEmailData *edata = maildir_edata_get(e);

    mutt_debug(LL_DEBUG1, "%c %s\n", e->old ? 'C' : 'N',
               highlight_filename(e->path, edata->uid_start, edata->uid_length));
  }
}

/**
 * dump_hash - XXX
 */
static void dump_hash(struct HashTable *hash)
{
  struct HashWalkState walk = { 0 };
  struct HashElem *he = NULL;

  mutt_debug(LL_DEBUG1, "------------------------------------------------------------\n");
  mutt_debug(LL_DEBUG1, "Hash Table\n");

  while ((he = mutt_hash_walk(hash, &walk)))
  {
    mutt_debug(LL_DEBUG1, "    %2d  %.*s\n", he->type, he->key.intkey, he->key.strkey);
  }
}

/**
 * maildir_find_uid - Find the unique part of the Maildir filename
 * @param[in]  filename   Filename
 * @param[out] uid_start  Where in the filename the uid starts
 * @param[out] uid_length Length of the uid
 *
 * @note maildir filename is defined as: \<base filename\>:2,\<flags\>
 *       but \<base filename\> may contain additional comma separated
 *       fields. Additionally, `:` may be replaced as the field
 *       delimiter by a user defined alternative.
 */
void maildir_find_uid(const char *filename, short *uid_start, short *uid_length)
{
  if (*uid_length > 0) // Already calculated
    return;

  const char *base = filename;
  const char *slash = strrchr(filename, '/');
  if (slash)
    base = slash + 1;

  *uid_start = (short) (base - filename);

  const char c_maildir_field_delimiter = *cc_maildir_field_delimiter();

  char end_chars[8] = { 0 };
  snprintf(end_chars, sizeof(end_chars), ",%c", c_maildir_field_delimiter);
  char *end = strpbrk(base, end_chars);

  if (end)
    *uid_length = (short) (end - base);
  else
    *uid_length = (short) mutt_str_len(base);
}

/**
 * maildir_parse_flags2 - Parse Maildir file flags
 * @param[in]  path   Path to email file
 * @param[out] custom Custom maildir flags
 */
MaildirFlags maildir_parse_flags2(const char *path, char **custom)
{
  const char c_maildir_field_delimiter = *cc_maildir_field_delimiter();
  char *p = strrchr(path, c_maildir_field_delimiter);
  if (!p)
    return MD_MF_NO_FLAGS;

  if (!mutt_str_startswith(p + 1, "2,"))
    return MD_MF_NO_FLAGS;

  p += 3;

  MaildirFlags flags = MD_MF_NO_FLAGS;

  char leftover[16] = { 0 };
  int num = 0;

  for (; *p; p++)
  {
    switch (*p)
    {
      case 'F':
        flags |= MD_MF_FLAGGED;
        break;

      case 'R':
        flags |= MD_MF_REPLIED;
        break;

      case 'S':
        flags |= MD_MF_SEEN;
        break;

      case 'T':
        flags |= MD_MF_TRASHED;
        break;

      default:
        leftover[num++] = *p;
        break;
    }
  }

  if (custom)
    *custom = mutt_str_dup(leftover);

  return flags;
}

/**
 * maildir_parse_flags3 - Parse Maildir file flags
 * @param[in]  path   Path to email file
 * @param[out] custom Buffer for custom maildir flags
 * @param[in]  clen   Length of buffer
 */
MaildirFlags maildir_parse_flags3(const char *path, char *custom, size_t clen)
{
  const char c_maildir_field_delimiter = *cc_maildir_field_delimiter();
  char *p = strrchr(path, c_maildir_field_delimiter);
  if (!p)
    return MD_MF_NO_FLAGS;

  if (!mutt_str_startswith(p + 1, "2,"))
    return MD_MF_NO_FLAGS;

  p += 3;

  MaildirFlags flags = MD_MF_NO_FLAGS;

  size_t num = 0;

  for (; *p && (num < clen); p++)
  {
    switch (*p)
    {
      case 'F':
        flags |= MD_MF_FLAGGED;
        break;

      case 'R':
        flags |= MD_MF_REPLIED;
        break;

      case 'S':
        flags |= MD_MF_SEEN;
        break;

      case 'T':
        flags |= MD_MF_TRASHED;
        break;

      default:
        custom[num++] = *p;
        break;
    }
  }

  custom[num] = '\0';
  return flags;
}

/**
 * merge_flags - XXX
 */
bool merge_flags(struct Email *e, MaildirFlags flags, char **custom)
{
  bool changed = false;

  bool flagged = (flags & MD_MF_FLAGGED);
  if (flagged != e->flagged)
    changed = true;
  e->flagged = flagged;

  bool read = (flags & MD_MF_SEEN);
  if (read != e->read)
    changed = true;
  e->read = read;

  bool replied = (flags & MD_MF_REPLIED);
  if (replied != e->replied)
    changed = true;
  e->replied = replied;

  if (flags & MD_MF_TRASHED)
  {
    const bool c_flag_safe = cs_subset_bool(NeoMutt->sub, "flag_safe");
    if (!e->flagged || !c_flag_safe)
    {
      e->trash = true;
      e->deleted = true;
    }
  }

  struct MaildirEmailData *edata = maildir_edata_get(e);

  FREE(edata->custom_flags);
  edata->custom_flags = *custom;
  *custom = NULL;

  return changed;
}

/**
 * merge_flags2 - XXX
 */
bool merge_flags2(struct Email *e, MaildirFlags flags, char *custom)
{
  bool changed = false;

  bool flagged = (flags & MD_MF_FLAGGED);
  if (flagged != e->flagged)
    changed = true;
  e->flagged = flagged;

  bool read = (flags & MD_MF_SEEN);
  if (read != e->read)
    changed = true;
  e->read = read;

  bool replied = (flags & MD_MF_REPLIED);
  if (replied != e->replied)
    changed = true;
  e->replied = replied;

  if (flags & MD_MF_TRASHED)
  {
    const bool c_flag_safe = cs_subset_bool(NeoMutt->sub, "flag_safe");
    if (!e->flagged || !c_flag_safe)
    {
      e->trash = true;
      e->deleted = true;
    }
  }

  struct MaildirEmailData *edata = maildir_edata_get(e);

  if (flags & MD_EC_CUSTOM_FLAGS)
  {
    mutt_str_replace(&edata->custom_flags, custom);
    changed = true;
  }

  return changed;
}

/**
 * maildir_parse_all_flags - XXX
 */
static void maildir_parse_all_flags(const struct EmailArray *ea, struct EmailArray *ea_cha)
{
  struct Email **ep = NULL;
  ARRAY_FOREACH(ep, ea)
  {
    struct Email *e = *ep;
    struct MaildirEmailData *edata = maildir_edata_get(e);

    char *custom = NULL;
    edata->disk_flags = maildir_parse_flags2(e->path, &custom);
    if (merge_flags(e, edata->disk_flags, &custom) && ea_cha)
    {
      ARRAY_ADD(ea_cha, e);
    }
  }
}

/**
 * filename_clear - Clear the contents of a Filename
 * @param f Filename
 *
 * @note The Filename itself isn't freed
 */
void filename_clear(struct Filename *f)
{
  FREE(&f->sub_name);
  f->uid_start = 0;
  f->uid_length = 0;
  f->is_cur = false;
}

/**
 * maildir_files_scan - Scan a Maildir directory for files
 * @param[in]     path     Path to the Mailbox
 * @param[in]     subdir   Name of the subdir, "cur" or "new"
 * @param[in,out] fa       Array for filenames
 * @param[in]     progress Progress Bar
 * @retval enum #MxOpenReturns
 *
 * @note May be interruped by Ctrl-C (SIGINT)
 */
enum MxOpenReturns maildir_files_scan(const char *path, const char *subdir,
                                      struct FilenameArray *fa, struct Progress *progress)
{
  struct Buffer *sub_name = NULL;
  struct Buffer *path_sub = buf_pool_get();
  buf_printf(path_sub, "%s/%s", path, subdir);
  enum MxOpenReturns rc = MX_OPEN_ERROR;

  DIR *dir = mutt_file_opendir(buf_string(path_sub), MUTT_OPENDIR_NONE);
  if (!dir)
    goto done;

  progress_set_message(progress, _("Scanning %s..."), path);

  sub_name = buf_pool_get();
  struct dirent *de = NULL;
  rc = MX_OPEN_ABORT;

  mutt_sig_allow_interrupt(true);
  while ((de = readdir(dir)))
  {
    if (SigInt)
    {
      SigInt = false; // LCOV_EXCL_LINE
      goto done;      // LCOV_EXCL_LINE
    }

    if (*de->d_name == '.')
      continue;

    buf_printf(sub_name, "%s/%s", subdir, de->d_name);

    struct Filename f = { 0 };
    f.sub_name = buf_strdup(sub_name);
    maildir_find_uid(f.sub_name, &f.uid_start, &f.uid_length);
    ARRAY_ADD(fa, f);
    progress_update(progress, ARRAY_SIZE(fa), -1);
  }
  rc = MX_OPEN_OK;

done:
  mutt_sig_allow_interrupt(false);
  closedir(dir);
  buf_pool_release(&sub_name);
  buf_pool_release(&path_sub);
  return rc;
}

/**
 * maildir_files_read - Read Maildir files from disk
 * @param[in]     mbox_path Path to Mailbox
 * @param[in,out] fa        Filenames to look up
 * @param[in,out] ea        Parsed Emails
 * @param[in]     progress  Progress Bar
 * @retval enum #MxOpenReturns
 *
 * For each filename in @a fa, read the Email from disk and parse it.
 * The Emails are stored in @a ea.
 *
 * @note May be interruped by Ctrl-C (SIGINT)
 */
enum MxOpenReturns maildir_files_read(const char *mbox_path, struct FilenameArray *fa,
                                      struct EmailArray *ea, struct Progress *progress)
{
  if (ARRAY_EMPTY(fa))
    return MX_OPEN_OK;

  struct Buffer *path_file = buf_pool_get();
  enum MxOpenReturns rc = MX_OPEN_ABORT;

  progress_set_size(progress, ARRAY_SIZE(fa));
  progress_set_message(progress, _("Reading files %s..."), mbox_path);

  struct Filename *fn = NULL;
  mutt_sig_allow_interrupt(true);
  ARRAY_FOREACH(fn, fa)
  {
    if (SigInt)
    {
      SigInt = false; // LCOV_EXCL_LINE
      goto done;      // LCOV_EXCL_LINE
    }

    if (!fn->sub_name) // Already processed
      continue;

    buf_concat_path(path_file, mbox_path, fn->sub_name);

    struct Email *e = maildir_email_new();
    if (maildir_parse_message(buf_string(path_file), fn->is_cur, e))
    {
      struct MaildirEmailData *edata = maildir_edata_get(e);

      maildir_find_uid(fn->sub_name, &edata->uid_start, &edata->uid_length);
      e->path = fn->sub_name; // Transfer string
      fn->sub_name = NULL;
      ARRAY_ADD(ea, e);
    }
    else
    {
      mutt_debug(LL_DEBUG2, "Couldn't parse: %s\n", fn->sub_name);
      FREE(&fn->sub_name);
      email_free(&e);
    }

    progress_update(progress, ARRAY_SIZE(ea), -1);
  }
  rc = MX_OPEN_OK;

done:
  mutt_sig_allow_interrupt(false);
  buf_pool_release(&path_file);
  return rc;
}

/**
 * maildir_move_to_mailbox2 - Move new Emails into a Mailbox
 * @param m  Mailbox
 * @param ea Array of Emails to move
 */
void maildir_move_to_mailbox2(struct Mailbox *m, struct EmailArray *ea)
{
  if (!m || !ea || ARRAY_EMPTY(ea))
    return;

  mx_alloc_memory(m, m->msg_count + ARRAY_SIZE(ea));

  struct Email **ep = NULL;
  ARRAY_FOREACH(ep, ea)
  {
    struct Email *e = *ep;

    mutt_debug(LL_DEBUG2, "Considering %s\n", e->path);
    mutt_debug(LL_DEBUG2, "Adding Email Flags: %s%s%s%s%s\n",
               e->flagged ? "f" : "", e->deleted ? "D" : "",
               e->replied ? "r" : "", e->old ? "O" : "", e->read ? "R" : "");

    m->emails[m->msg_count] = e;
    m->emails[m->msg_count]->index = m->msg_count;
    mailbox_size_add(m, e);

    m->msg_count++;
  }

  // ARRAY_FREE(ea);
}

/**
 * check_dir - XXX
 */
bool check_dir(const char *mbox_path, const char *subdir, struct timespec *mtime, bool force)
{
  bool rc = false;
  struct Buffer *dir = NULL;

  dir = buf_pool_get();
  buf_concat_path(dir, mbox_path, subdir);

  struct stat st = { 0 };
  if (stat(buf_string(dir), &st) == -1)
    goto done;

  struct timespec a = { 0 };

  mutt_file_get_stat_timespec(&a, &st, MUTT_STAT_MTIME);

  if (!force && (mutt_file_timespec_compare(&a, mtime) < 0))
    goto done;

  *mtime = a; // Save last check times
  rc = true;

done:
  buf_pool_release(&dir);
  return rc;
}

/**
 * hash_emails_by_uid - XXX
 */
struct HashTable *hash_emails_by_uid(const struct Mailbox *m)
{
  struct HashTable *table = mutt_hash_new(m->msg_count, MUTT_HASH_NO_FLAGS);

  for (size_t i = 0; i < m->msg_count; i++)
  {
    struct Email *e = m->emails[i];
    if (!e)
      continue;

    const struct MaildirEmailData *edata = maildir_edata_get(e);

    mutt_hash_typed_insert_n(table, e->path + edata->uid_start, edata->uid_length, i, e);
  }

  return table;
}

/**
 * email_compare - XXX
 */
EmailCompareFlags email_compare(struct Email *e, const struct Filename *fn)
{
  EmailCompareFlags changes = MD_EC_NO_FLAGS;

  struct MaildirEmailData *edata = maildir_edata_get(e);

  // if (edata->uid_length != fn->uid_length)
  //   changes |= MD_EC_FILENAME;

  // if (!mutt_strn_equal(e->path + uid_start, fn->sub_name + fn->uid_start, fn->uid_length))
  //   changes |= MD_EC_FILENAME;

  if (!mutt_str_equal(e->path, fn->sub_name))
    changes |= MD_EC_FILENAME;

  if (e->old != fn->is_cur)
    changes |= MD_EC_DIRECTORY; // new to cur, or vice versa

  char *custom = NULL;
  MaildirFlags flags = maildir_parse_flags2(fn->sub_name, &custom);
  if (flags != edata->disk_flags)
    changes |= MD_EC_FLAGS;

  if (e->flagged != !!(flags & MD_MF_FLAGGED))
    changes |= MD_EC_FLAGS;

  if (e->replied != !!(flags & MD_MF_REPLIED))
    changes |= MD_EC_FLAGS;

  if (e->read != !!(flags & MD_MF_SEEN))
    changes |= MD_EC_FLAGS;

  if (e->trash != !!(flags & MD_MF_TRASHED))
    changes |= MD_EC_FLAGS;

  if (!mutt_str_equal(edata->custom_flags, custom))
    changes |= MD_EC_CUSTOM_FLAGS;

  merge_flags(e, flags, &custom);

  if (changes != MD_EC_NO_FLAGS)
  {
    mutt_debug(LL_DEBUG1, "REPLACING %s with %s\n", e->path, fn->sub_name);
    mutt_str_replace(&e->path, fn->sub_name);
  }

  FREE(&custom);
  return changes;
}

/**
 * email_compare2 - XXX
 *
 * Assumes UID is the same (it's the same file)
 */
EmailCompareFlags email_compare2(struct Email *e, const struct Filename *fn,
                                 MaildirFlags flags, char *custom)
{
  EmailCompareFlags changes = MD_EC_NO_FLAGS;

  struct MaildirEmailData *edata = maildir_edata_get(e);

  if (!mutt_str_equal(e->path, fn->sub_name))
    changes |= MD_EC_FILENAME;

  if (e->old != fn->is_cur)
    changes |= MD_EC_DIRECTORY; // new to cur, or vice versa

  if (flags != edata->disk_flags)
    changes |= MD_EC_FLAGS;

  if (e->flagged != !!(flags & MD_MF_FLAGGED))
    changes |= MD_EC_FLAGS;

  if (e->replied != !!(flags & MD_MF_REPLIED))
    changes |= MD_EC_FLAGS;

  if (e->read != !!(flags & MD_MF_SEEN))
    changes |= MD_EC_FLAGS;

  if (e->trash != !!(flags & MD_MF_TRASHED))
    changes |= MD_EC_FLAGS;

  if (!mutt_str_equal(edata->custom_flags, custom))
    changes |= MD_EC_CUSTOM_FLAGS;

  return changes;
}

/**
 * sync_flagged - XXX
 */
bool sync_flagged(struct MaildirEmailData *edata, const struct Filename *fn)
{
  MaildirFlags flags = maildir_parse_flags2(fn->sub_name, NULL);
  const bool disk = (flags & MD_MF_FLAGGED);
  const bool cached = (edata->disk_flags & MD_MF_FLAGGED);

  if (disk == cached)
    return false;

  if (disk)
    edata->disk_flags |= MD_MF_FLAGGED; // Set flag
  else
    edata->disk_flags &= MD_MF_FLAGGED; // Clear flag

  return true;
}

/**
 * maildir_check_new - XXX
 */
enum MxStatus maildir_check_new(struct Mailbox *m, MaildirCheckFlags cflags)
{
  if (cflags == MMC_NO_DIRS)
    return MX_STATUS_OK;

  struct FilenameArray fa_sca = ARRAY_HEAD_INITIALIZER; ///< Files: scanned
  struct FilenameArray fa_cha = ARRAY_HEAD_INITIALIZER; ///< Files: changed
  struct FilenameArray fa_new = ARRAY_HEAD_INITIALIZER; ///< Files: new
  struct EmailArray ea_new = ARRAY_HEAD_INITIALIZER;    ///< Emails: new
  struct EmailArray ea_cha = ARRAY_HEAD_INITIALIZER;    ///< Emails: changed
  struct EmailArray ea_del = ARRAY_HEAD_INITIALIZER;    ///< Emails: deleted
  const char *path = mailbox_path(m);
  // struct MaildirMboxData *mdata = maildir_mdata_get(m);
  struct Progress *progress = NULL;
  struct HeaderCache *hc = NULL;
  struct HashTable *hash_uids = NULL; // Hash Table: Maildir "uid" -> MdEmail

  enum MxOpenReturns rc = MX_OPEN_ERROR;

  // Maybe?
  // if (m->verbose)
  //   progress = progress_new(MUTT_PROGRESS_READ, 0);

  if (cflags & MMC_CUR_DIR)
  {
    rc = maildir_files_scan(path, "cur", &fa_sca, progress);
    if (rc != MX_OPEN_OK)
      goto done;

    struct Filename *fn = NULL;
    ARRAY_FOREACH(fn, &fa_sca)
    {
      fn->is_cur = true;
    }
  }

  if (cflags & MMC_NEW_DIR)
  {
    rc = maildir_files_scan(path, "new", &fa_sca, progress);
    if (rc != MX_OPEN_OK)
      goto done;
  }

  dump_filenames(&fa_sca, "Scanned");

  hash_uids = hash_emails_by_uid(m);

  dump_hash(hash_uids);
  mutt_debug(LL_DEBUG1, "------------------------------------------------------------\n");

  struct Filename *fn = NULL;
  ARRAY_FOREACH(fn, &fa_sca)
  {
    struct HashElem *he = mutt_hash_find_elem_n(hash_uids, fn->sub_name + fn->uid_start,
                                                fn->uid_length);
    struct Email *e = he ? he->data : NULL;
    if (e)
    {
      mutt_debug(LL_DEBUG1, "Found: %s\n",
                 highlight_filename(fn->sub_name, fn->uid_start, fn->uid_length));
      char custom[32] = { 0 };
      MaildirFlags flags = maildir_parse_flags3(fn->sub_name, custom, sizeof(custom));

      EmailCompareFlags cmp = email_compare2(e, fn, flags, custom);
      if (cmp == MD_EC_NO_FLAGS)
      {
        mutt_debug(LL_DEBUG1, "\tNO CHANGE\n");
        he->type = -1;
        filename_clear(fn); // Done
      }
      else
      {
        if (merge_flags2(e, flags, custom))
        {
          // need to hcache_store()
        }

        mutt_debug(LL_DEBUG1, "\tCHANGES %d\n", cmp);
        he->type = -1;
        ARRAY_ADD(&fa_cha, *fn); // Transfer the filename
        fn->sub_name = NULL;
        ARRAY_ADD(&ea_cha, e);
      }
    }
    else
    {
      // NEW EMAIL
      mutt_debug(LL_DEBUG1, "NEW: %s\n",
                 highlight_filename(fn->sub_name, fn->uid_start, fn->uid_length));
      ARRAY_ADD(&fa_new, *fn); // Transfer the filename
      fn->sub_name = NULL;
    }
  }

  struct HashWalkState walk = { 0 };
  struct HashElem *he = NULL;
  while ((he = mutt_hash_walk(hash_uids, &walk)))
  {
    int index = he->type;
    if (index >= 0)
    {
      struct Email *e = he->data;
      struct MaildirEmailData *edata = maildir_edata_get(e);
      ARRAY_ADD(&ea_del, e); // Transfer the Email
      mutt_debug(LL_DEBUG1, "DELETED: %s\n",
                 highlight_filename(e->path, edata->uid_start, edata->uid_length));
      m->emails[index] = NULL;
    }
  }

  // dump_filenames(&fa_sca, "Scanned");
  // dump_filenames(&fa_cha, "Changed");
  dump_filenames(&fa_new, "New");

  dump_emails(&ea_cha, "Changed");
  dump_emails(&ea_del, "Deleted");

  dump_hash(hash_uids);

  hc = maildir_hcache_open(m);

  rc = maildir_hcache_read(hc, path, &fa_new, &ea_new, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  rc = maildir_files_read(path, &fa_new, &ea_new, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  // maildir_parse_all_flags(&ea, &ea_cha);

  rc = maildir_hcache_delete(hc, &ea_del, path, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  // NEW, CHANGED, UNCHANGED, DELETED
  //   NEW       -> hcache_store -> ea_new
  //   CHANGED   -> hcache_store -> ea_cha
  //   UNCHANGED -> NOP
  //   DELETED   -> hcache_delete_record (ea_del)

  maildir_move_to_mailbox2(m, &ea_new);

  // move to mailbox
  // NEW, CHANGED, UNCHANGED, DELETED
  //   NEW       -> add to end of emails[]
  //   CHANGED   -> NOP
  //   UNCHANGED -> NOP
  //   DELETED   -> NOP

  if ((ARRAY_SIZE(&ea_new) != 0) || (ARRAY_SIZE(&ea_cha) != 0) || (ARRAY_SIZE(&ea_del) != 0))
  {
    struct EventMailbox ev_m = { m, &ea_new, &ea_cha, &ea_del };
    notify_send(m->notify, NT_MAILBOX, NT_MAILBOX_CHANGE, &ev_m);
  }

  // notify (NEW, CHANGED, DELETED)
  // expect index to move deleted to the end of emails[]

  // move to mailbox
  // NEW, CHANGED, UNCHANGED, DELETED
  //   NEW       -> NOP
  //   CHANGED   -> NOP
  //   UNCHANGED -> NOP
  //   DELETED   -> remove from emails[]

  // hash emails
  // ∀ fn in hash -> eliminate
  // hcache lookup ∀ fa_sca -> ea
  // read files ∀ fa_sca -> ea
  // hcache store ∀ ea
  // move to mailbox
  // notify ∀ ea

  rc = MX_STATUS_OK;

done:
  maildir_hcache_close(&hc);
  progress_free(&progress);
  mutt_hash_free(&hash_uids);

  ARRAY_FOREACH(fn, &fa_sca)
  {
    filename_clear(fn);
  }
  ARRAY_FREE(&fa_sca);

  struct Email **ep = NULL;
  ARRAY_FOREACH(ep, &ea_del)
  {
    email_free(ep);
  }
  ARRAY_FREE(&ea_del);

  return rc;
}

/**
 * maildir_check_slow - XXX
 */
enum MxStatus maildir_check_slow(struct Mailbox *m, bool force)
{
  MaildirCheckFlags changed = MMC_NO_DIRS;
  const char *path = mailbox_path(m);
  struct MaildirMboxData *mdata = maildir_mdata_get(m);

  if (check_dir(path, "new", &mdata->mtime, force))
    changed |= MMC_NEW_DIR;

  if (check_dir(path, "cur", &mdata->mtime_cur, force))
    changed |= MMC_CUR_DIR;

  return maildir_check_new(m, changed);
}

/**
 * maildir_sync2 - XXX
 */
enum MxStatus maildir_sync2(struct Mailbox *m)
{
  struct FilenameArray fa_sca = ARRAY_HEAD_INITIALIZER; ///< Files: scanned
  struct FilenameArray fa_cha = ARRAY_HEAD_INITIALIZER; ///< Files: changed
  struct FilenameArray fa_new = ARRAY_HEAD_INITIALIZER; ///< Files: new
  struct EmailArray ea_new = ARRAY_HEAD_INITIALIZER;    ///< Emails: new
  struct EmailArray ea_cha = ARRAY_HEAD_INITIALIZER;    ///< Emails: changed
  struct EmailArray ea_del = ARRAY_HEAD_INITIALIZER;    ///< Emails: deleted
  const char *path = mailbox_path(m);
  // struct MaildirMboxData *mdata = maildir_mdata_get(m);
  struct Progress *progress = NULL;
  struct HeaderCache *hc = NULL;
  struct HashTable *hash_uids = NULL; // Hash Table: Maildir "uid" -> MdEmail

  enum MxOpenReturns rc = MX_OPEN_ERROR;

  // Maybe?
  // if (m->verbose)
  //   progress = progress_new(MUTT_PROGRESS_READ, 0);

  rc = maildir_files_scan(path, "cur", &fa_sca, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  struct Filename *fn = NULL;
  ARRAY_FOREACH(fn, &fa_sca)
  {
    fn->is_cur = true;
  }

  rc = maildir_files_scan(path, "new", &fa_sca, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  dump_filenames(&fa_sca, "Scanned");

  hash_uids = hash_emails_by_uid(m);

  dump_hash(hash_uids);
  mutt_debug(LL_DEBUG1, "------------------------------------------------------------\n");

  ARRAY_FOREACH(fn, &fa_sca)
  {
    struct HashElem *he = mutt_hash_find_elem_n(hash_uids, fn->sub_name + fn->uid_start,
                                                fn->uid_length);
    struct Email *e = he ? he->data : NULL;
    if (e)
    {
      mutt_debug(LL_DEBUG1, "Found: %s\n",
                 highlight_filename(fn->sub_name, fn->uid_start, fn->uid_length));
      EmailCompareFlags flags = email_compare(e, fn);
      if (flags == MD_EC_NO_FLAGS)
      {
        mutt_debug(LL_DEBUG1, "\tNO CHANGE\n");
        he->type = -1;
        filename_clear(fn); // Done
      }
      else
      {
        mutt_debug(LL_DEBUG1, "\tCHANGES %d\n", flags);
        he->type = -1;
        ARRAY_ADD(&fa_cha, *fn); // Transfer the filename
        fn->sub_name = NULL;
        ARRAY_ADD(&ea_cha, e);
      }
    }
    else
    {
      // NEW EMAIL
      mutt_debug(LL_DEBUG1, "NEW: %s\n",
                 highlight_filename(fn->sub_name, fn->uid_start, fn->uid_length));
      ARRAY_ADD(&fa_new, *fn); // Transfer the filename
      fn->sub_name = NULL;
    }
  }

  struct HashWalkState walk = { 0 };
  struct HashElem *he = NULL;
  while ((he = mutt_hash_walk(hash_uids, &walk)))
  {
    int index = he->type;
    if (index >= 0)
    {
      struct Email *e = he->data;
      ARRAY_ADD(&ea_del, e); // Transfer the Email
      m->emails[index] = NULL;
    }
  }

  // dump_filenames(&fa_sca, "Scanned");
  // dump_filenames(&fa_cha, "Changed");
  dump_filenames(&fa_new, "New");

  dump_emails(&ea_cha, "Changed");
  dump_emails(&ea_del, "Deleted");

  dump_hash(hash_uids);

  hc = maildir_hcache_open(m);

  rc = maildir_hcache_read(hc, path, &fa_new, &ea_new, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  rc = maildir_files_read(path, &fa_new, &ea_new, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  // maildir_parse_all_flags(&ea, &ea_cha);

  rc = maildir_hcache_delete(hc, &ea_del, path, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  // NEW, CHANGED, UNCHANGED, DELETED
  //   NEW       -> hcache_store -> ea_new
  //   CHANGED   -> hcache_store -> ea_cha
  //   UNCHANGED -> NOP
  //   DELETED   -> hcache_delete_record (ea_del)

  maildir_move_to_mailbox2(m, &ea_new);

  // move to mailbox
  // NEW, CHANGED, UNCHANGED, DELETED
  //   NEW       -> add to end of emails[]
  //   CHANGED   -> NOP
  //   UNCHANGED -> NOP
  //   DELETED   -> NOP

  if ((ARRAY_SIZE(&ea_new) != 0) || (ARRAY_SIZE(&ea_cha) != 0) || (ARRAY_SIZE(&ea_del) != 0))
  {
    struct EventMailbox ev_m = { m, &ea_new, &ea_cha, &ea_del };
    notify_send(m->notify, NT_MAILBOX, NT_MAILBOX_CHANGE, &ev_m);
  }

  // notify (NEW, CHANGED, DELETED)
  // expect index to move deleted to the end of emails[]

  // move to mailbox
  // NEW, CHANGED, UNCHANGED, DELETED
  //   NEW       -> NOP
  //   CHANGED   -> NOP
  //   UNCHANGED -> NOP
  //   DELETED   -> remove from emails[]

  // hash emails
  // ∀ fn in hash -> eliminate
  // hcache lookup ∀ fa_sca -> ea
  // read files ∀ fa_sca -> ea
  // hcache store ∀ ea
  // move to mailbox
  // notify ∀ ea

  rc = MX_STATUS_OK;

done:
  maildir_hcache_close(&hc);
  progress_free(&progress);
  mutt_hash_free(&hash_uids);

  ARRAY_FOREACH(fn, &fa_sca)
  {
    filename_clear(fn);
  }
  ARRAY_FREE(&fa_sca);

  struct Email **ep = NULL;
  ARRAY_FOREACH(ep, &ea_del)
  {
    email_free(ep);
  }
  ARRAY_FREE(&ea_del);

  return rc;
}

// Mailbox API -----------------------------------------------------------------

/**
 * maildir_mbox_open - Open a Mailbox - Implements MxOps::mbox_open() - @ingroup mx_mbox_open
 */
enum MxOpenReturns maildir_mbox_open(struct Mailbox *m)
{
  struct FilenameArray fa = ARRAY_HEAD_INITIALIZER;
  struct EmailArray ea = ARRAY_HEAD_INITIALIZER;
  struct EmailArray ea_cha = ARRAY_HEAD_INITIALIZER;
  const char *path = mailbox_path(m);
  struct Progress *progress = NULL;
  struct Filename *fn = NULL;
  enum MxOpenReturns rc;

  struct HeaderCache *hc = maildir_hcache_open(m);

  if (m->verbose)
    progress = progress_new(MUTT_PROGRESS_READ, 0);

  // Scan the cur and new directories, saving the filenames to fa
  rc = maildir_files_scan(path, "cur", &fa, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  ARRAY_FOREACH(fn, &fa)
  {
    fn->is_cur = true;
  }
  rc = maildir_files_scan(path, "new", &fa, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  dump_filenames(&fa, "Scanned");

  // Search the Header Cache for each filename in fa, saving the Emails to ea
  rc = maildir_hcache_read(hc, path, &fa, &ea, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  size_t count_cache = ARRAY_SIZE(&ea);

  // Read and parse any uncached files, saving the Emails to ea
  rc = maildir_files_read(path, &fa, &ea, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  dump_emails(&ea, "Maildir");
  mutt_debug(LL_DEBUG1, "------------------------------------------------------------\n");

  maildir_parse_all_flags(&ea, &ea_cha);

  progress_set_size(progress, ARRAY_SIZE(&fa) - count_cache);

  // Save any uncached Emails to the Header Cache
  rc = maildir_hcache_store(hc, &ea, count_cache, path, progress);
  if (rc != MX_OPEN_OK)
    goto done;

  rc = maildir_hcache_store(hc, &ea_cha, 0, path, NULL);
  if (rc != MX_OPEN_OK)
    goto done;
  ARRAY_FREE(&ea_cha);

  struct MaildirMboxData *mdata = maildir_mdata_get(m);
  if (!mdata)
  {
    mdata = maildir_mdata_new();
    m->mdata = mdata;
    m->mdata_free = maildir_mdata_free;
  }

  if (mdata->umask == 0)
    mdata->umask = maildir_umask(m);

  // Move the Emails into Mailbox.emails[]
  maildir_move_to_mailbox2(m, &ea);
  ARRAY_FREE(&ea);

  struct EmailArray ea_new = ARRAY_HEAD_INITIALIZER; ///< Emails: new
  struct EmailArray ea_del = ARRAY_HEAD_INITIALIZER; ///< Emails: deleted
  struct EventMailbox ev_m = { m, &ea_new, &ea_cha, &ea_del };
  ARRAY_RESERVE(ev_m.ea_new, m->msg_count);
  for (int i = 0; i < m->msg_count; i++)
  {
    ARRAY_ADD(ev_m.ea_new, m->emails[i]);
  }
  notify_send(m->notify, NT_MAILBOX, NT_MAILBOX_CHANGE, &ev_m);
  ARRAY_FREE(&ea_new);
  rc = MX_OPEN_OK;

done:
  maildir_hcache_close(&hc);
  progress_free(&progress);

  ARRAY_FOREACH(fn, &fa)
  {
    filename_clear(fn);
  }
  ARRAY_FREE(&fa);

  struct Email **ep = NULL;
  ARRAY_FOREACH(ep, &ea)
  {
    email_free(ep);
  }
  ARRAY_FREE(&ea);
  ARRAY_FREE(&ea_cha);

  return rc;
}

/**
 * maildir_mbox_open_append - Open a Mailbox for appending - Implements MxOps::mbox_open_append() - @ingroup mx_mbox_open_append
 */
bool maildir_mbox_open_append(struct Mailbox *m, OpenMailboxFlags flags)
{
  if (!(flags & (MUTT_APPEND | MUTT_APPENDNEW)))
  {
    return true;
  }

  errno = 0;
  if ((mutt_file_mkdir(mailbox_path(m), S_IRWXU) != 0) && (errno != EEXIST))
  {
    mutt_perror("%s", mailbox_path(m));
    return false;
  }

  char tmp[PATH_MAX] = { 0 };
  snprintf(tmp, sizeof(tmp), "%s/cur", mailbox_path(m));
  errno = 0;
  if ((mkdir(tmp, S_IRWXU) != 0) && (errno != EEXIST))
  {
    mutt_perror("%s", tmp);
    rmdir(mailbox_path(m));
    return false;
  }

  snprintf(tmp, sizeof(tmp), "%s/new", mailbox_path(m));
  errno = 0;
  if ((mkdir(tmp, S_IRWXU) != 0) && (errno != EEXIST))
  {
    mutt_perror("%s", tmp);
    snprintf(tmp, sizeof(tmp), "%s/cur", mailbox_path(m));
    rmdir(tmp);
    rmdir(mailbox_path(m));
    return false;
  }

  snprintf(tmp, sizeof(tmp), "%s/tmp", mailbox_path(m));
  errno = 0;
  if ((mkdir(tmp, S_IRWXU) != 0) && (errno != EEXIST))
  {
    mutt_perror("%s", tmp);
    snprintf(tmp, sizeof(tmp), "%s/cur", mailbox_path(m));
    rmdir(tmp);
    snprintf(tmp, sizeof(tmp), "%s/new", mailbox_path(m));
    rmdir(tmp);
    rmdir(mailbox_path(m));
    return false;
  }

  return true;
}

/**
 * maildir_mbox_check - Check for new mail - Implements MxOps::mbox_check() - @ingroup mx_mbox_check
 */
enum MxStatus maildir_mbox_check(struct Mailbox *m)
{
  return maildir_check(m);
}

/**
 * maildir_mbox_check_stats - Check the Mailbox statistics - Implements MxOps::mbox_check_stats() - @ingroup mx_mbox_check_stats
 */
enum MxStatus maildir_mbox_check_stats(struct Mailbox *m, uint8_t flags)
{
  if (!m->mdata)
    return MX_STATUS_OK;

  maildir_check_slow(m, true);
  return MX_STATUS_OK;

  bool check_stats = flags & MUTT_MAILBOX_CHECK_STATS;
  bool check_new = true;

  if (check_stats)
  {
    m->msg_new = 0;
    m->msg_count = 0;
    m->msg_unread = 0;
    m->msg_flagged = 0;
  }

  maildir_check_dir(m, "new", check_new, check_stats);

  const bool c_maildir_check_cur = cs_subset_bool(NeoMutt->sub, "maildir_check_cur");
  check_new = !m->has_new && c_maildir_check_cur;
  if (check_new || check_stats)
    maildir_check_dir(m, "cur", check_new, check_stats);

  return m->msg_new ? MX_STATUS_NEW_MAIL : MX_STATUS_OK;
}

/**
 * maildir_mbox_sync - Save changes to the Mailbox - Implements MxOps::mbox_sync() - @ingroup mx_mbox_sync
 * @retval enum #MxStatus
 *
 * @note The flag retvals come from a call to a backend sync function
 */
enum MxStatus maildir_mbox_sync(struct Mailbox *m)
{
  return maildir_sync2(m);

  enum MxStatus check = maildir_check(m);
  if (check == MX_STATUS_ERROR)
    return check;

  struct HeaderCache *hc = NULL;
#ifdef USE_HCACHE
  const char *const c_header_cache = cs_subset_path(NeoMutt->sub, "header_cache");
  hc = hcache_open(c_header_cache, mailbox_path(m), NULL, true);
#endif

  struct Progress *progress = NULL;
  if (m->verbose)
  {
    progress = progress_new(MUTT_PROGRESS_WRITE, m->msg_count);
    progress_set_message(progress, _("Writing %s..."), mailbox_path(m));
  }

  for (int i = 0; i < m->msg_count; i++)
  {
    progress_update(progress, i, -1);

    struct Email *e = m->emails[i];
    if (!maildir_sync_mailbox_message(m, e, hc))
    {
      progress_free(&progress);
      goto err;
    }
  }
  progress_free(&progress);

#ifdef USE_HCACHE
  hcache_close(&hc);
#endif

  /* XXX race condition? */

  maildir_update_mtime(m);

  /* adjust indices */

  if (m->msg_deleted)
  {
    const bool c_maildir_trash = cs_subset_bool(NeoMutt->sub, "maildir_trash");
    for (int i = 0, j = 0; i < m->msg_count; i++)
    {
      struct Email *e = m->emails[i];
      if (!e)
        break;

      if (!e->deleted || c_maildir_trash)
        e->index = j++;
    }
  }

  return check;

err:
#ifdef USE_HCACHE
  hcache_close(&hc);
#endif
  return MX_STATUS_ERROR;
}

/**
 * maildir_mbox_close - Close a Mailbox - Implements MxOps::mbox_close() - @ingroup mx_mbox_close
 * @retval #MX_STATUS_OK Always
 */
enum MxStatus maildir_mbox_close(struct Mailbox *m)
{
  return MX_STATUS_OK;
}
